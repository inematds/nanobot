<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Nanobot - Arquitetura e Funcionamento</title>
  <style>
    :root {
      --bg: #0d1117;
      --bg-card: #161b22;
      --bg-code: #1c2128;
      --border: #30363d;
      --text: #e6edf3;
      --text-muted: #8b949e;
      --accent: #58a6ff;
      --accent-hover: #79c0ff;
      --green: #3fb950;
      --orange: #d29922;
      --red: #f85149;
      --purple: #bc8cff;
    }

    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
      background: var(--bg);
      color: var(--text);
      line-height: 1.7;
      font-size: 16px;
    }

    /* HEADER */
    header {
      background: var(--bg-card);
      border-bottom: 1px solid var(--border);
      padding: 2rem 0;
      text-align: center;
      position: relative;
    }

    header h1 {
      font-size: 2.2rem;
      font-weight: 700;
      margin-bottom: 0.5rem;
    }

    header h1 span { color: var(--accent); }

    header p {
      color: var(--text-muted);
      font-size: 1.1rem;
      max-width: 600px;
      margin: 0 auto;
    }

    /* NAV */
    nav {
      background: var(--bg-card);
      border-bottom: 1px solid var(--border);
      position: sticky;
      top: 0;
      z-index: 100;
      overflow-x: auto;
      -webkit-overflow-scrolling: touch;
    }

    nav ul {
      list-style: none;
      display: flex;
      max-width: 1100px;
      margin: 0 auto;
      padding: 0 1rem;
    }

    nav li a {
      display: block;
      padding: 0.75rem 1rem;
      color: var(--text-muted);
      text-decoration: none;
      font-size: 0.85rem;
      white-space: nowrap;
      border-bottom: 2px solid transparent;
      transition: color 0.2s, border-color 0.2s;
    }

    nav li a:hover,
    nav li a.active {
      color: var(--accent);
      border-bottom-color: var(--accent);
    }

    nav li a.nav-home {
      color: #fff;
      background: var(--accent);
      border-radius: 4px;
      padding: 0.4rem 0.9rem;
      font-weight: 600;
      border-bottom: 2px solid transparent;
    }

    nav li a.nav-home:hover {
      background: var(--accent-hover);
      color: #fff;
      border-bottom-color: transparent;
    }

    /* MOBILE NAV TOGGLE */
    .nav-toggle {
      display: none;
      background: var(--bg-card);
      border: 1px solid var(--border);
      color: var(--text);
      padding: 0.5rem 1rem;
      font-size: 0.9rem;
      cursor: pointer;
      width: 100%;
      text-align: left;
      border-radius: 0;
    }

    /* MAIN */
    main {
      max-width: 900px;
      margin: 0 auto;
      padding: 2rem 1.5rem 4rem;
    }

    /* SECTIONS */
    section {
      margin-bottom: 3rem;
      scroll-margin-top: 60px;
    }

    h2 {
      font-size: 1.7rem;
      font-weight: 700;
      margin-bottom: 1rem;
      padding-bottom: 0.5rem;
      border-bottom: 1px solid var(--border);
      color: var(--text);
    }

    h2 .num {
      color: var(--accent);
      margin-right: 0.3rem;
    }

    h3 {
      font-size: 1.2rem;
      font-weight: 600;
      margin: 1.5rem 0 0.7rem;
      color: var(--text);
    }

    p { margin-bottom: 1rem; }

    strong { color: var(--text); }

    a { color: var(--accent); text-decoration: none; }
    a:hover { color: var(--accent-hover); text-decoration: underline; }

    /* CODE */
    pre {
      background: var(--bg-code);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 1rem 1.2rem;
      overflow-x: auto;
      margin: 1rem 0;
      font-size: 0.85rem;
      line-height: 1.6;
    }

    code {
      font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace;
      font-size: 0.88em;
    }

    p code, li code, td code {
      background: var(--bg-code);
      border: 1px solid var(--border);
      border-radius: 4px;
      padding: 0.15em 0.4em;
      font-size: 0.85em;
    }

    pre code {
      background: none;
      border: none;
      padding: 0;
      font-size: inherit;
    }

    /* TABLES */
    table {
      width: 100%;
      border-collapse: collapse;
      margin: 1rem 0;
      font-size: 0.92rem;
    }

    th, td {
      padding: 0.6rem 0.8rem;
      text-align: left;
      border: 1px solid var(--border);
    }

    th {
      background: var(--bg-code);
      font-weight: 600;
      color: var(--text);
    }

    td { background: var(--bg-card); }

    tr:hover td { background: #1c2433; }

    /* CARDS */
    .card {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 1.2rem 1.5rem;
      margin: 1rem 0;
    }

    .card h4 {
      color: var(--accent);
      margin-bottom: 0.5rem;
      font-size: 1rem;
    }

    /* DIAGRAM */
    .diagram {
      background: var(--bg-code);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 1.5rem;
      margin: 1.5rem 0;
      text-align: center;
      overflow-x: auto;
    }

    .diagram pre {
      display: inline-block;
      text-align: left;
      border: none;
      padding: 0;
      margin: 0;
      background: none;
    }

    /* FLOW STEPS */
    .flow {
      position: relative;
      padding-left: 2.5rem;
      margin: 1.5rem 0;
    }

    .flow::before {
      content: '';
      position: absolute;
      left: 0.85rem;
      top: 0;
      bottom: 0;
      width: 2px;
      background: var(--border);
    }

    .flow-step {
      position: relative;
      margin-bottom: 1.2rem;
      padding: 0.8rem 1rem;
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 8px;
    }

    .flow-step::before {
      content: attr(data-step);
      position: absolute;
      left: -2.2rem;
      top: 0.8rem;
      width: 1.5rem;
      height: 1.5rem;
      background: var(--accent);
      color: var(--bg);
      border-radius: 50%;
      font-size: 0.75rem;
      font-weight: 700;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .flow-step .label {
      font-weight: 600;
      color: var(--accent);
      display: block;
      margin-bottom: 0.3rem;
    }

    .flow-step .desc {
      color: var(--text-muted);
      font-size: 0.92rem;
    }

    /* BADGE */
    .badge {
      display: inline-block;
      padding: 0.15em 0.5em;
      border-radius: 4px;
      font-size: 0.8em;
      font-weight: 600;
    }
    .badge-green { background: #1a3a2a; color: var(--green); }
    .badge-orange { background: #3a2e1a; color: var(--orange); }
    .badge-red { background: #3a1a1a; color: var(--red); }
    .badge-purple { background: #2a1a3a; color: var(--purple); }
    .badge-blue { background: #1a2a3a; color: var(--accent); }

    /* UL */
    ul, ol {
      margin: 0.5rem 0 1rem 1.5rem;
    }

    li { margin-bottom: 0.3rem; }

    /* BACK TO TOP */
    .back-top {
      position: fixed;
      bottom: 2rem;
      right: 2rem;
      background: var(--accent);
      color: var(--bg);
      width: 40px;
      height: 40px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      text-decoration: none;
      font-size: 1.2rem;
      box-shadow: 0 2px 8px rgba(0,0,0,0.4);
      opacity: 0;
      transition: opacity 0.3s;
    }
    .back-top.visible { opacity: 1; }

    /* FOOTER */
    footer {
      text-align: center;
      padding: 2rem;
      color: var(--text-muted);
      font-size: 0.85rem;
      border-top: 1px solid var(--border);
    }

    /* RESPONSIVE */
    @media (max-width: 768px) {
      header h1 { font-size: 1.6rem; }
      main { padding: 1.5rem 1rem 3rem; }
      h2 { font-size: 1.4rem; }
      nav ul { flex-wrap: wrap; }
      nav li a { padding: 0.5rem 0.7rem; font-size: 0.8rem; }
      pre { font-size: 0.78rem; padding: 0.8rem; }
      table { font-size: 0.82rem; }
      th, td { padding: 0.4rem 0.5rem; }
    }
  </style>
</head>
<body>

<header>
  <h1><span>nanobot</span> &mdash; Arquitetura</h1>
  <p>Como funciona por dentro o assistente pessoal ultra-leve em ~3.400 linhas de Python</p>
</header>

<nav id="navbar">
  <ul>
    <li><a href="index.html" class="nav-home">Inicio</a></li>
    <li><a href="#visao-geral">Visao Geral</a></li>
    <li><a href="#as-7-pecas">As 7 Pecas</a></li>
    <li><a href="#extras">Extras</a></li>
    <li><a href="#fluxo-completo">Fluxo Completo</a></li>
    <li><a href="#tecnologias">Tecnologias</a></li>
    <li><a href="#arquivos">Arquivos</a></li>
  </ul>
</nav>

<main>

  <!-- VISAO GERAL -->
  <section id="visao-geral">
    <h2>Visao Geral</h2>
    <p>O nanobot funciona como um <strong>telefone com secretaria inteligente</strong>:</p>
    <ol>
      <li>Voce manda uma mensagem pelo Telegram (ou Discord, WhatsApp...)</li>
      <li>A mensagem entra numa <strong>fila de espera</strong></li>
      <li>Um <strong>agente</strong> pega a mensagem, pensa (usando uma IA como GPT/Claude/Qwen), e pode usar <strong>ferramentas</strong> (ler arquivos, executar comandos, buscar na web)</li>
      <li>A resposta volta pela mesma fila e chega no seu Telegram</li>
    </ol>
    <p>O codigo todo tem <strong>~3.400 linhas</strong> e e dividido em <strong>7 pecas principais</strong> que se conectam como engrenagens.</p>
  </section>

  <!-- AS 7 PECAS -->
  <section id="as-7-pecas">
    <h2>As 7 Pecas do Nanobot</h2>
    <div class="diagram">
<pre><code>+-----------------------------------------------------------+
|                VOCE (Telegram, Discord...)                 |
+-----------------------------+-----------------------------+
                              |
                         (1) CHANNELS
                        (recebe e envia)
                              |
                         (2) MESSAGE BUS
                        (fila de espera)
                              |
                         (3) AGENT LOOP
                        (cerebro principal)
                              |
                  +-----------+-----------+
                  |           |           |
             (4) PROVIDER  (5) TOOLS  (6) CONTEXT
             (chama a IA)  (faz coisas) (memoria)
                  |           |           |
                  +-----------+-----------+
                              |
                         (7) SESSIONS
                        (historico salvo)</code></pre>
    </div>
  </section>

  <!-- CHANNELS -->
  <section id="channels">
    <h2><span class="num">1.</span> Channels &mdash; A porta de entrada</h2>
    <p><strong>Arquivo principal:</strong> <code>nanobot/channels/telegram.py</code> (e discord.py, whatsapp.py, etc.)</p>
    <p>Pense no channel como um <strong>porteiro</strong>. Cada plataforma (Telegram, Discord, WhatsApp) tem seu porteiro, e todos fazem a mesma coisa:</p>
    <ol>
      <li><strong>Ficam escutando</strong> &mdash; o Telegram usa "polling" (a cada poucos segundos pergunta "tem mensagem nova?")</li>
      <li><strong>Verificam seguranca</strong> &mdash; confere se o remetente esta na lista <code>allowFrom</code>. Se nao esta, ignora</li>
      <li><strong>Limitam velocidade</strong> &mdash; se alguem mandar 100 mensagens por segundo, bloqueia (rate limit)</li>
      <li><strong>Padronizam</strong> &mdash; converte a mensagem de cada plataforma para um formato unico interno</li>
    </ol>

    <h3>O que o channel cria</h3>
<pre><code class="language-python">InboundMessage(
    channel   = "telegram",        # de onde veio
    sender_id = "123456789",      # quem mandou
    chat_id   = "123456789",      # qual chat
    content   = "Oi, tudo bem?",   # a mensagem
    media     = [],                # fotos, audios...
)</code></pre>

    <p>Todos os channels herdam de <code>BaseChannel</code> &mdash; um "molde" que ja traz seguranca e rate limit prontos. Cada plataforma so precisa implementar como conectar e como enviar mensagem de volta.</p>

    <h3>Channels implementados</h3>
    <table>
      <tr><th>Channel</th><th>Como recebe</th><th>Biblioteca</th></tr>
      <tr><td>Telegram</td><td>Polling (pergunta a cada X segundos)</td><td>python-telegram-bot</td></tr>
      <tr><td>WhatsApp</td><td>WebSocket para bridge Node.js</td><td>baileys (JS)</td></tr>
      <tr><td>Discord</td><td>Gateway WebSocket</td><td>discord.py</td></tr>
      <tr><td>Feishu</td><td>WebSocket longa conexao</td><td>SDK proprio</td></tr>
      <tr><td>DingTalk</td><td>Stream mode</td><td>SDK proprio</td></tr>
    </table>
  </section>

  <!-- BUS -->
  <section id="bus">
    <h2><span class="num">2.</span> Message Bus &mdash; A fila de espera</h2>
    <p><strong>Arquivo:</strong> <code>nanobot/bus/queue.py</code> (~60 linhas)</p>
    <p>O bus e a peca mais simples: sao <strong>duas filas</strong> (como a fila do banco).</p>

<pre><code>FILA DE ENTRADA (inbound):    Channels colocam &rarr; Agent retira
FILA DE SAIDA   (outbound):   Agent coloca     &rarr; Channels retiram</code></pre>

<pre><code class="language-python">class MessageBus:
    inbound  = asyncio.Queue(maxsize=1000)   # fila de entrada
    outbound = asyncio.Queue(maxsize=1000)   # fila de saida</code></pre>

    <div class="card">
      <h4>Por que o bus existe?</h4>
      <p><strong>Desacoplamento.</strong> O Telegram nao precisa esperar o agente responder. Ele joga a mensagem na fila e volta a escutar. O agente processa quando puder. Se chegarem 10 mensagens ao mesmo tempo, ficam na fila esperando a vez.</p>
      <p>Se a fila encher (1000 mensagens), as novas sao descartadas com um aviso no log.</p>
    </div>
  </section>

  <!-- AGENT -->
  <section id="agent">
    <h2><span class="num">3.</span> Agent Loop &mdash; O cerebro</h2>
    <p><strong>Arquivo:</strong> <code>nanobot/agent/loop.py</code></p>
    <p>Este e o coracao do nanobot. Funciona assim:</p>

<pre><code>LOOP INFINITO:
  1. Pega proxima mensagem da fila de entrada
  2. Busca o historico da conversa (sessao)
  3. Monta o "contexto" (personalidade + memoria + skills)
  4. Manda tudo para a IA (provider)
  5. A IA responde com TEXTO ou pedido de FERRAMENTA
  6. Se pediu ferramenta &rarr; executa &rarr; volta pro passo 4 com o resultado
  7. Se respondeu com texto &rarr; salva no historico &rarr; coloca na fila de saida</code></pre>

    <h3>Codigo simplificado</h3>
<pre><code class="language-python">async def run(self):
    while True:
        msg = await bus.consume_inbound()         # 1. espera mensagem
        await self._process_message(msg)           # 2-7. processa

async def _process_message(self, msg):
    session = session_manager.get_or_create(msg.session_key)
    messages = context_builder.build(session, msg)

    for iteration in range(20):                    # max 20 rodadas
        response = await provider.chat(messages, tools)

        if response.tool_calls:                    # IA quer ferramenta?
            for tool_call in response.tool_calls:
                result = await tools.execute(
                    tool_call.name, tool_call.args
                )
                messages.append({
                    "role": "tool", "content": result
                })
        else:                                      # IA respondeu texto
            await bus.publish_outbound(OutboundMessage(
                channel=msg.channel,
                chat_id=msg.chat_id,
                content=response.content
            ))
            break

    session.save()</code></pre>

    <div class="card">
      <h4>Ponto-chave</h4>
      <p>A IA pode pedir para usar ferramentas, e o loop executa e devolve o resultado. Isso pode acontecer ate <strong>20 vezes</strong> numa unica mensagem (por exemplo: a IA le um arquivo, depois executa um comando, depois busca na web, e finalmente responde).</p>
    </div>
  </section>

  <!-- PROVIDER -->
  <section id="provider">
    <h2><span class="num">4.</span> Provider &mdash; A conexao com a IA</h2>
    <p><strong>Arquivo:</strong> <code>nanobot/providers/litellm_provider.py</code></p>
    <p>O provider e quem <strong>faz a chamada para a API</strong> do modelo de linguagem (GPT, Claude, Qwen, etc.).</p>
    <p>O nanobot usa uma biblioteca chamada <strong>LiteLLM</strong> que funciona como um "tradutor universal" &mdash; voce manda no formato OpenAI e ele traduz para qualquer provider:</p>

<pre><code class="language-python">class LiteLLMProvider:
    async def chat(self, messages, tools, model):
        response = await litellm.acompletion(
            model       = "openrouter/qwen/qwen3-coder-next",
            messages    = messages,       # conversa inteira
            tools       = tools,          # ferramentas disponiveis
            temperature = 0.7,
            max_tokens  = 8192,
        )
        return LLMResponse(
            content    = response.content,
            tool_calls = response.tool_calls,
        )</code></pre>

    <h3>O Registry de Providers</h3>
    <p><strong>Arquivo:</strong> <code>nanobot/providers/registry.py</code></p>
    <p>Cada provider tem uma "spec" que diz como configurar:</p>

<pre><code class="language-python">ProviderSpec(
    name="openrouter",
    env_key="OPENROUTER_API_KEY",
    keywords=("openrouter",),
    is_gateway=True,               # aceita qualquer modelo
    detect_by_key_prefix="sk-or-", # detecta pelo prefixo da chave
)</code></pre>

    <p>Isso permite que <strong>adicionar um provider novo</strong> precise de apenas 2 mudancas (a spec + um campo na config).</p>

    <h3>Providers suportados</h3>
    <table>
      <tr><th>Provider</th><th>Tipo</th><th>Modelos</th></tr>
      <tr><td>OpenRouter</td><td><span class="badge badge-green">Gateway</span></td><td>Todos (Claude, GPT, Qwen, Llama...)</td></tr>
      <tr><td>AiHubMix</td><td><span class="badge badge-green">Gateway</span></td><td>Todos</td></tr>
      <tr><td>Anthropic</td><td><span class="badge badge-blue">Direto</span></td><td>Claude</td></tr>
      <tr><td>OpenAI</td><td><span class="badge badge-blue">Direto</span></td><td>GPT</td></tr>
      <tr><td>DeepSeek</td><td><span class="badge badge-blue">Direto</span></td><td>DeepSeek</td></tr>
      <tr><td>Groq</td><td><span class="badge badge-blue">Direto</span></td><td>Llama, Whisper (voz)</td></tr>
      <tr><td>Gemini</td><td><span class="badge badge-blue">Direto</span></td><td>Gemini</td></tr>
      <tr><td>Dashscope</td><td><span class="badge badge-blue">Direto</span></td><td>Qwen</td></tr>
      <tr><td>Moonshot</td><td><span class="badge badge-blue">Direto</span></td><td>Kimi</td></tr>
      <tr><td>vLLM</td><td><span class="badge badge-purple">Local</span></td><td>Qualquer (servidor local)</td></tr>
    </table>
  </section>

  <!-- TOOLS -->
  <section id="tools">
    <h2><span class="num">5.</span> Tools &mdash; As ferramentas do agente</h2>
    <p><strong>Arquivos:</strong> <code>nanobot/agent/tools/</code> (6 arquivos)</p>
    <p>Tools sao as "maos" do agente. Sem elas, ele so fala. Com elas, ele <strong>faz coisas</strong>.</p>
    <p>Cada tool e uma classe Python:</p>

<pre><code class="language-python">class ReadFileTool(Tool):
    name = "read_file"
    description = "Read contents of a file"
    parameters = {
        "path": {"type": "string", "description": "File path"}
    }

    async def execute(self, path):
        return open(path).read()</code></pre>

    <h3>Tools disponiveis</h3>
    <table>
      <tr><th>Tool</th><th>O que faz</th><th>Protecoes</th></tr>
      <tr><td><code>read_file</code></td><td>Le um arquivo (max 10MB)</td><td>Restrito ao workspace</td></tr>
      <tr><td><code>write_file</code></td><td>Cria/escreve arquivo</td><td>Restrito ao workspace</td></tr>
      <tr><td><code>edit_file</code></td><td>Edita linhas especificas</td><td>Restrito ao workspace</td></tr>
      <tr><td><code>list_dir</code></td><td>Lista diretorio</td><td>Restrito ao workspace</td></tr>
      <tr><td><code>exec</code></td><td>Executa comando no terminal</td><td>Bloqueia <code>rm -rf</code>, <code>dd</code>, fork bombs</td></tr>
      <tr><td><code>web_search</code></td><td>Busca na web (Brave Search)</td><td>Precisa de API key</td></tr>
      <tr><td><code>web_fetch</code></td><td>Le uma pagina web</td><td>Protecao SSRF</td></tr>
      <tr><td><code>message</code></td><td>Envia mensagem ao usuario</td><td>&mdash;</td></tr>
      <tr><td><code>spawn</code></td><td>Cria sub-agente background</td><td>Max 5 simultaneos</td></tr>
      <tr><td><code>cron</code></td><td>Agenda tarefas recorrentes</td><td>&mdash;</td></tr>
    </table>

    <h3>Como a IA usa as tools</h3>
    <p>A IA recebe uma lista de "funcoes disponiveis" no formato JSON Schema. Quando decide usar uma, responde assim:</p>

<pre><code class="language-json">{
    "tool_calls": [{
        "id": "call_abc123",
        "function": {
            "name": "read_file",
            "arguments": "{\"path\": \"/workspace/arquivo.txt\"}"
        }
    }]
}</code></pre>
    <p>O agent loop executa, pega o resultado, e manda de volta pra IA pra ela continuar pensando.</p>

    <h3>Seguranca do <code>exec</code></h3>
    <p>O tool de terminal tem a protecao mais pesada:</p>
<pre><code class="language-python"># Padroes bloqueados:
BLOCKED = ["rm -rf /", "dd if=", ":(){ :|:", "mkfs", "> /dev/"]

# Injecao de comandos detectada:
INJECTION = [";", "&&", "||", "|", "`", "$("]

# Se restrict_to_workspace = true:
# Todo comando roda dentro de ~/.nanobot/workspace/ apenas</code></pre>
  </section>

  <!-- CONTEXT -->
  <section id="context">
    <h2><span class="num">6.</span> Context &mdash; Personalidade e Memoria</h2>
    <p><strong>Arquivo:</strong> <code>nanobot/agent/context.py</code></p>
    <p>Quando o agente vai responder, ele precisa de <strong>contexto</strong> &mdash; quem ele e, o que sabe, o que o usuario ja disse. O ContextBuilder monta tudo isso num "system prompt".</p>

    <h3>O que vai no contexto (nesta ordem)</h3>
    <table>
      <tr><th>#</th><th>Conteudo</th><th>Origem</th></tr>
      <tr><td>1</td><td><strong>Identidade</strong> &mdash; "Voce e o nanobot, assistente pessoal"</td><td>Hardcoded + data/hora</td></tr>
      <tr><td>2</td><td><strong>Bootstrap files</strong> &mdash; AGENTS.md, SOUL.md, USER.md</td><td><code>~/.nanobot/workspace/</code></td></tr>
      <tr><td>3</td><td><strong>Memoria</strong> &mdash; MEMORY.md + notas dos ultimos 7 dias</td><td><code>~/.nanobot/workspace/memory/</code></td></tr>
      <tr><td>4</td><td><strong>Skills</strong> &mdash; lista resumida ou conteudo completo</td><td><code>nanobot/skills/</code></td></tr>
      <tr><td>5</td><td><strong>Historico</strong> &mdash; ultimas 50 mensagens deste chat</td><td>Sessao (.jsonl)</td></tr>
      <tr><td>6</td><td><strong>Mensagem atual</strong> do usuario</td><td>InboundMessage</td></tr>
    </table>

    <h3>Memoria persistente</h3>
    <p><strong>Arquivo:</strong> <code>nanobot/agent/memory.py</code></p>
<pre><code>~/.nanobot/workspace/memory/
+-- MEMORY.md           &larr; Memoria permanente (agente pode editar)
+-- 2026-02-10.md       &larr; Notas de hoje (agente pode adicionar)</code></pre>
    <p>O agente pode escrever na memoria usando o tool <code>write_file</code>. Na proxima conversa, o contexto inclui essas memorias automaticamente.</p>
  </section>

  <!-- SESSIONS -->
  <section id="sessions">
    <h2><span class="num">7.</span> Sessions &mdash; Historico Salvo</h2>
    <p><strong>Arquivo:</strong> <code>nanobot/session/manager.py</code></p>
    <p>Cada conversa e uma <strong>sessao</strong> identificada por <code>channel:chat_id</code> (ex: <code>telegram:123456789</code>).</p>
    <p>As sessoes ficam salvas como arquivos <code>.jsonl</code> (uma linha JSON por mensagem):</p>

<pre><code>~/.nanobot/sessions/
+-- telegram_123456789.jsonl</code></pre>

    <p>Conteudo do arquivo:</p>
<pre><code class="language-json">{"_type":"metadata","created_at":"2026-02-10T05:30:00"}
{"role":"user","content":"Oi!","timestamp":"2026-02-10T05:31:00"}
{"role":"assistant","content":"Ola! Como posso ajudar?","timestamp":"2026-02-10T05:31:05"}</code></pre>

    <h3>Limites</h3>
    <table>
      <tr><th>Limite</th><th>Valor</th></tr>
      <tr><td>Mensagens por sessao</td><td>1000 (descarta as mais antigas)</td></tr>
      <tr><td>Tamanho max por mensagem</td><td>100KB</td></tr>
      <tr><td>Sessoes em cache na RAM</td><td>100 (LRU &mdash; remove as menos usadas)</td></tr>
      <tr><td>Validade</td><td>30 dias (auto-deletadas)</td></tr>
      <tr><td>Gravacao</td><td>Atomica (temp &rarr; rename, nunca corrompe)</td></tr>
    </table>
  </section>

  <!-- EXTRAS -->
  <section id="extras">
    <h2>Pecas Extras</h2>

    <h3>Cron &mdash; Tarefas agendadas</h3>
    <p><strong>Arquivo:</strong> <code>nanobot/cron/service.py</code></p>
    <p>Um timer que roda a cada 10-30 segundos verificando se tem tarefa pra executar:</p>

<pre><code class="language-python">CronJob(
    name     = "bom dia",
    schedule = CronSchedule(kind="cron", expr="0 9 * * *"),  # todo dia 9h
    payload  = CronPayload(message="Diga bom dia!"),
)</code></pre>

    <p>Quando chega a hora, o cron manda a mensagem do job como se fosse um usuario &rarr; o agente processa normalmente &rarr; a resposta vai pro channel configurado.</p>
    <p>Tipos de agendamento:</p>
    <table>
      <tr><th>Tipo</th><th>Exemplo</th><th>Descricao</th></tr>
      <tr><td><code>every</code></td><td><code>every_ms: 3600000</code></td><td>Repete a cada N milissegundos (min 60s)</td></tr>
      <tr><td><code>cron</code></td><td><code>"0 9 * * *"</code></td><td>Expressao cron padrao</td></tr>
      <tr><td><code>at</code></td><td><code>at_ms: 1739145600000</code></td><td>Uma vez na data/hora especifica</td></tr>
    </table>

    <h3>Heartbeat &mdash; Batimento cardiaco</h3>
    <p><strong>Arquivo:</strong> <code>nanobot/heartbeat/service.py</code></p>
    <p>A cada 30 minutos, o heartbeat "cutuca" o agente: "leia o HEARTBEAT.md e faca o que tiver la". Se nao tem nada, o agente responde <code>HEARTBEAT_OK</code> e volta a dormir.</p>

    <h3>Subagent &mdash; Tarefas em background</h3>
    <p><strong>Arquivo:</strong> <code>nanobot/agent/subagent.py</code></p>
    <p>O agente pode "se clonar" pra fazer tarefas demoradas em paralelo:</p>

<pre><code>Agente recebe: "pesquise sobre X e me mande um relatorio"
  &rarr; Cria subagent com a tarefa
  &rarr; Responde imediatamente: "Estou pesquisando em background!"
  &rarr; Subagent roda independente (com acesso a tools)
  &rarr; Quando termina, manda o resultado pro chat do usuario</code></pre>
    <p>Maximo <strong>5 subagents simultaneos</strong>.</p>

    <h3>Skills &mdash; Habilidades do agente</h3>
    <p><strong>Arquivo:</strong> <code>nanobot/agent/skills.py</code></p>
    <p>Skills sao pacotes de conhecimento em Markdown (<code>SKILL.md</code>) que o agente carrega conforme necessario:</p>
    <ol>
      <li>Skills <strong>always-on</strong> &rarr; conteudo completo no prompt</li>
      <li>Skills <strong>disponiveis</strong> &rarr; resumo no prompt, agente carrega via <code>read_file</code> se precisar</li>
      <li>Skills <strong>indisponiveis</strong> &rarr; listados com o que falta instalar</li>
    </ol>

    <table>
      <tr><th>Skill</th><th>Descricao</th><th>Requer</th></tr>
      <tr><td>remotion</td><td>Criacao de videos em React (35 regras + 3 exemplos)</td><td><code>npx</code></td></tr>
      <tr><td>agent-browser</td><td>Automacao de browser</td><td><code>agent-browser</code></td></tr>
      <tr><td>github</td><td>GitHub via <code>gh</code> CLI</td><td><code>gh</code></td></tr>
      <tr><td>summarize</td><td>Resumir URLs e videos</td><td><code>summarize</code></td></tr>
      <tr><td>weather</td><td>Clima e previsao</td><td>&mdash;</td></tr>
      <tr><td>tmux</td><td>Sessoes tmux</td><td><code>tmux</code></td></tr>
      <tr><td>cron</td><td>Agendar lembretes</td><td>&mdash;</td></tr>
      <tr><td>skill-creator</td><td>Criar novos skills</td><td>&mdash;</td></tr>
    </table>
  </section>

  <!-- FLUXO COMPLETO -->
  <section id="fluxo-completo">
    <h2>Fluxo Completo: Da mensagem a resposta</h2>
    <p>Exemplo: voce digita <strong>"Qual o clima em SP?"</strong> no Telegram.</p>

    <div class="flow">
      <div class="flow-step" data-step="1">
        <span class="label">CHANNEL &mdash; Telegram recebe</span>
        <span class="desc">O polling detecta a mensagem. Verifica: esta no <code>allowFrom</code>? Sim. Cria <code>InboundMessage</code>.</span>
      </div>
      <div class="flow-step" data-step="2">
        <span class="label">BUS &mdash; Entra na fila</span>
        <span class="desc"><code>bus.publish_inbound(msg)</code> coloca na fila de entrada.</span>
      </div>
      <div class="flow-step" data-step="3">
        <span class="label">AGENT &mdash; Pega da fila</span>
        <span class="desc"><code>bus.consume_inbound()</code> retira. Busca sessao <code>telegram:123456789</code>.</span>
      </div>
      <div class="flow-step" data-step="4">
        <span class="label">CONTEXT &mdash; Monta o prompt</span>
        <span class="desc">Sistema + SOUL.md + memoria + skills + ultimas 50 msgs + "Qual o clima em SP?"</span>
      </div>
      <div class="flow-step" data-step="5">
        <span class="label">PROVIDER &mdash; Chama a IA</span>
        <span class="desc"><code>provider.chat()</code> &rarr; API OpenRouter &rarr; qwen3-coder-next. IA responde: <code>tool_call("web_fetch", url="wttr.in/Sao+Paulo")</code></span>
      </div>
      <div class="flow-step" data-step="6">
        <span class="label">TOOL &mdash; Executa ferramenta</span>
        <span class="desc"><code>web_fetch</code> busca a pagina do wttr.in. Resultado: "Sao Paulo: 28 C, parcialmente nublado..."</span>
      </div>
      <div class="flow-step" data-step="7">
        <span class="label">PROVIDER &mdash; Chama a IA de novo</span>
        <span class="desc">Agora com o resultado do wttr.in. IA responde com texto: "O clima em Sao Paulo esta 28 C, parcialmente nublado"</span>
      </div>
      <div class="flow-step" data-step="8">
        <span class="label">SESSION &mdash; Salva historico</span>
        <span class="desc">Mensagem do usuario + resposta salvos no <code>.jsonl</code></span>
      </div>
      <div class="flow-step" data-step="9">
        <span class="label">BUS &mdash; Fila de saida</span>
        <span class="desc"><code>bus.publish_outbound()</code> coloca a resposta na fila de saida.</span>
      </div>
      <div class="flow-step" data-step="10">
        <span class="label">CHANNEL &mdash; Telegram envia</span>
        <span class="desc"><code>TelegramChannel.send()</code> converte para HTML e envia via API do Telegram.</span>
      </div>
    </div>

    <div class="card">
      <h4>Tempo total</h4>
      <p><strong>5-30 segundos</strong> dependendo da velocidade da IA e dos tools usados.</p>
    </div>
  </section>

  <!-- TECNOLOGIAS -->
  <section id="tecnologias">
    <h2>Tecnologias Utilizadas</h2>
    <table>
      <tr><th>Parte</th><th>Tecnologia</th><th>Por que</th></tr>
      <tr><td>Linguagem</td><td>Python 3.11+</td><td>Async/await nativo, ecossistema IA</td></tr>
      <tr><td>CLI</td><td>Typer + Rich</td><td>Interface bonita com cores</td></tr>
      <tr><td>Async</td><td>asyncio</td><td>Multiplos channels simultaneos sem threads</td></tr>
      <tr><td>LLM</td><td>LiteLLM</td><td>Suporta 100+ providers com uma API so</td></tr>
      <tr><td>Config</td><td>Pydantic v2</td><td>Validacao automatica do JSON</td></tr>
      <tr><td>Sessoes</td><td>JSONL</td><td>Um arquivo por conversa, append-only</td></tr>
      <tr><td>Telegram</td><td>python-telegram-bot</td><td>Oficial, bem mantida</td></tr>
      <tr><td>WhatsApp</td><td>Baileys (Node.js)</td><td>Unica opcao gratuita</td></tr>
      <tr><td>Seguranca</td><td>Rate limit + allowlist + workspace restriction</td><td>Defense in depth</td></tr>
    </table>

    <div class="card">
      <h4>Por que so ~3.400 linhas?</h4>
      <p>O projeto faz escolhas minimalistas: usa <strong>LiteLLM</strong> em vez de implementar cada provider, usa <strong>asyncio.Queue</strong> em vez de Redis/RabbitMQ, e mantem cada componente com <strong>responsabilidade unica</strong>. Nada de frameworks pesados &mdash; so Python puro com algumas bibliotecas bem escolhidas.</p>
    </div>
  </section>

  <!-- ARQUITETURA COMPLETA -->
  <section id="arquitetura">
    <h2>Diagrama Completo</h2>
    <div class="diagram">
<pre><code>+-------------------------------------------------------------+
|                    PLATAFORMAS DO USUARIO                    |
|       (Telegram, Discord, WhatsApp, Feishu, DingTalk)       |
+-----------------------------+-------------------------------+
                              |
                              v
                +---------------------------+
                |      CHANNEL LAYER        |
                |   TelegramChannel          |
                |   WhatsAppChannel          |
                |   DiscordChannel           |
                |                           |
                |  - Polling / WebSockets   |
                |  - Conversao de formato   |
                |  - Seguranca (allowFrom)  |
                +------------+--------------+
                             |
                +------------v--------------+
                |     MESSAGE BUS           |
                |                           |
                | inbound.Queue  &larr; channels |
                | outbound.Queue &rarr; channels |
                |                           |
                +------------+--------------+
                             |
                +------------v--------------+
                |       AGENT LOOP          |
                |                           |
                | 1. consume_inbound()      |
                | 2. build_messages()       |
                | 3. while iteration &lt; 20:  |
                |    - LLM.chat()           |
                |    - if tool_calls:       |
                |      execute_tools()      |
                |    - else: break          |
                | 4. save_session()         |
                | 5. publish_outbound()     |
                +------------+--------------+
                             |
      +----------+-----------+-----------+----------+
      |          |           |           |          |
+-----v----+ +--v------+ +-v--------+ +v-------+ +v---------+
| Provider | | Tools   | | Context  | |Sessions| | Skills   |
| (LiteLLM)| | (6 tipos)| | Builder  | |(.jsonl)| | (.md)    |
+----------+ +---------+ +----------+ +--------+ +----------+
      |          |           |
+-----v----+ +--v------+ +-v--------+
|  OpenAI  | | exec    | | SOUL.md  |
|  Claude  | | files   | | AGENTS.md|
|  Qwen    | | web     | | MEMORY.md|
|  Llama   | | message | | USER.md  |
|  ...     | | spawn   | | Skills   |
+----------+ | cron    | +----------+
             +---------+</code></pre>
    </div>
  </section>

  <!-- MAPA DE ARQUIVOS -->
  <section id="arquivos">
    <h2>Mapa de Arquivos</h2>
    <table>
      <tr><th>Componente</th><th>Arquivo</th><th>Responsabilidade</th></tr>
      <tr><td>CLI / Entry</td><td><code>cli/commands.py</code></td><td>Todos os comandos, startup do gateway</td></tr>
      <tr><td>Agent Core</td><td><code>agent/loop.py</code></td><td>Processamento de mensagens, loop de tools</td></tr>
      <tr><td>Bus</td><td><code>bus/queue.py</code></td><td>Filas async de mensagens</td></tr>
      <tr><td>Channels</td><td><code>channels/base.py</code>, <code>telegram.py</code>...</td><td>Integracao com plataformas</td></tr>
      <tr><td>LLM</td><td><code>providers/litellm_provider.py</code></td><td>Chamadas API, multi-provider</td></tr>
      <tr><td>Sessions</td><td><code>session/manager.py</code></td><td>Persistencia de historico</td></tr>
      <tr><td>Context</td><td><code>agent/context.py</code></td><td>Montagem do system prompt</td></tr>
      <tr><td>Memory</td><td><code>agent/memory.py</code></td><td>Memoria de longo prazo e notas diarias</td></tr>
      <tr><td>Tools</td><td><code>agent/tools/*.py</code></td><td>Capacidades do agente (6 arquivos)</td></tr>
      <tr><td>Skills</td><td><code>agent/skills.py</code></td><td>Descoberta e carregamento</td></tr>
      <tr><td>Config</td><td><code>config/schema.py</code>, <code>loader.py</code></td><td>Gerenciamento de configuracao</td></tr>
      <tr><td>Cron</td><td><code>cron/service.py</code></td><td>Agendamento de tarefas</td></tr>
      <tr><td>Heartbeat</td><td><code>heartbeat/service.py</code></td><td>Wake-up periodico</td></tr>
      <tr><td>Subagents</td><td><code>agent/subagent.py</code></td><td>Tarefas em background</td></tr>
      <tr><td>Seguranca</td><td><code>security/ratelimit.py</code>, <code>validators.py</code></td><td>Rate limit, validacao, sanitizacao</td></tr>
    </table>
  </section>

</main>

<a href="#" class="back-top" id="backTop" title="Voltar ao topo">&uarr;</a>

<footer>
  <p>nanobot &mdash; Ultra-Lightweight Personal AI Assistant</p>
  <p><a href="https://github.com/inematds/nanobot">github.com/inematds/nanobot</a></p>
</footer>

<script>
  // Back to top button
  const btn = document.getElementById('backTop');
  window.addEventListener('scroll', () => {
    btn.classList.toggle('visible', window.scrollY > 400);
  });

  // Active nav highlight
  const sections = document.querySelectorAll('section[id]');
  const navLinks = document.querySelectorAll('nav a[href^="#"]');

  const observer = new IntersectionObserver(entries => {
    entries.forEach(entry => {
      if (entry.isIntersecting) {
        navLinks.forEach(link => {
          link.classList.toggle('active',
            link.getAttribute('href') === '#' + entry.target.id
          );
        });
      }
    });
  }, { rootMargin: '-20% 0px -75% 0px' });

  sections.forEach(s => observer.observe(s));
</script>

</body>
</html>
